#!/usr/bin/env python3

# List files in long or short format, depending on screen size.
#
# 2013  Bence Kalmar

import sys
import os
import os.path
import argparse
import subprocess
import shutil

# only used for error & help messages, not argument parsing
parser = argparse.ArgumentParser(
    description="""\
List files in long or short format, depending on screen size.

Call `ls -l' and `ls', passing it all arguments.  Print the output of `ls -l',
unless it's too long to fit on the screen, then print the output of `ls'.
""",
    epilog="""
The lines the prompt takes up is taken into account: the environment variable
${PS1} is examined for that if available.

See also `ls --help' for more info on `ls'.
""",
    formatter_class=argparse.RawDescriptionHelpFormatter
    )

parser.add_argument(
    "arg",
    metavar="ARG",
    help="Pass to `ls'.",
    nargs="*"
    )


def prompt_lines():
    shell = os.getenv("SHELL")
    if shell is None:
        prompt = None
    elif os.path.basename(shell) == "fish":
        try:
            prompt = subprocess.check_output("fish_prompt",
                                             shell=True, executable=shell)
        except subprocess.CalledProcessError as e:
            prompt = None
    else:
        prompt = os.getenv("PS1")
    return len(prompt.splitlines()) if prompt is not None else 0

def parse_args():
    res = sys.argv[1:]
    for s in ("-h", "--h", "--he", "--hel", "--help"):
        if s in res:
            parser.print_help()
            sys.exit(0)
    return res


def main():
    args = parse_args()
    terminal_size = shutil.get_terminal_size(None)
    if terminal_size is None:
        parser.error("could not get terminal size")

    # use correct width
    command = ["ls", "--width", str(terminal_size.columns)]
    ls_long = command + ["-l"] + args
    # `-C` is needed, otherwise ls prints only 1 column since it recognizes that
    # the output is not a tty
    ls_short = command + ["-C"] + args
    lines = terminal_size.lines - prompt_lines() - 1

    try:
        op_long = subprocess.check_output(ls_long, universal_newlines=True)
        op_short = subprocess.check_output(ls_short, universal_newlines=True)
    except subprocess.CalledProcessError as e:
        sys.exit(e.returncode)

    if len(op_long.splitlines()) <= lines:
        sys.stdout.write(op_long)
    else:
        sys.stdout.write(op_short)

if __name__ == "__main__":
    main()
